name: CI/CD Pipeline

on:
  push:
    branches: [ "main", "develop" ]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'notebooks/**'
      - 'pyproject.toml'
      - 'pixi.toml'
      - 'Makefile'
      - '.github/workflows/**'
  pull_request:
    branches: [ "main", "develop" ]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'notebooks/**'
      - 'pyproject.toml'
      - 'pixi.toml'
      - 'Makefile'
      - '.github/workflows/**'

jobs:
  test:
    name: Tests unitaires et linting
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@v0.5.2
      with:
        pixi-version: 'v0.32.0'
    
    - name: Install dependencies
      run: pixi install
    
    - name: Setup package in development mode
      run: pixi run setup
    
    - name: Run linting and formatting checks
      run: pixi run lint
    
    - name: Run tests with coverage
      run: pixi run test
    
    - name: Generate HTML coverage report
      run: pixi run pytest --cov=src --cov-report=html --cov-report=xml
      
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        
    - name: Upload coverage reports as artifacts
      uses: actions/upload-artifact@v4
      with:
        name: coverage-reports
        path: |
          htmlcov/
          coverage.xml
  
  deploy-coverage:
    name: Deploy Coverage Report to GitHub Pages
    runs-on: ubuntu-22.04
    needs: test
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@v0.5.2
      with:
        pixi-version: 'v0.32.0'
    
    - name: Install dependencies
      run: pixi install
    
    - name: Download coverage artifact
      uses: actions/download-artifact@v4
      with:
        name: coverage-reports
        path: ./
    
    - name: Configure Git
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
    
    - name: Extract coverage percentage
      run: |
        # Exécute le script d'extraction de couverture avec pixi
        pixi run python scripts/extract_coverage.py coverage.xml coverage.json
        
        # Affiche le pourcentage extrait
        cat coverage.json
    
    - name: Deploy to gh-pages branch
      run: |
        # Clone la branche gh-pages
        git fetch origin gh-pages
        git checkout gh-pages
        
        # Nettoie le répertoire sauf .nojekyll
        find . -maxdepth 1 ! -name '.nojekyll' ! -name '.git' ! -name '.' -exec rm -rf {} +
        
        # Copie les fichiers de couverture
        cp -r htmlcov/* .
        
        # Copie le fichier JSON de métriques
        cp ../coverage.json .
        
        # Commit et push
        git add .
        git commit -m "Deploy coverage report $(date '+%Y-%m-%d %H:%M:%S')"
        git push origin gh-pages
  
  build:
    name: Build and package
    runs-on: ubuntu-22.04
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@v0.5.2
      with:
        pixi-version: 'v0.32.0'
    
    - name: Install dependencies
      run: pixi install
    
    - name: Build package
      run: |
        pip install build
        python -m build
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: python-package-dist
        path: dist/
  
  notebook-test:
    name: Test des notebooks
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@v0.5.2
      with:
        pixi-version: 'v0.32.0'
    
    - name: Install dependencies
      run: pixi install
    
    - name: Test notebooks with nbconvert
      run: |
        # Test that notebooks can be executed without errors
        for notebook in notebooks/*.ipynb; do
          echo "Testing notebook: $notebook"
          pixi run python -m nbconvert --to notebook --execute "$notebook" --output-dir /tmp
        done
  
  openshift-deploy:
    name: Déploiement OpenShift (simulé)
    runs-on: ubuntu-22.04
    needs: [test, build]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup OpenShift CLI
      run: |
        # Simulation pour l'instant - à remplacer par la vraie configuration OC
        echo "OpenShift deployment would run here"
        echo "OC CLI would be configured with secrets"
    
    - name: Build Docker image
      run: |
        echo "Building Docker image for OpenShift deployment"
        # Cette étape serait implémentée avec les manifests OpenShift réels
        
    - name: Deploy to OpenShift
      run: |
        echo "Deploying to OpenShift namespace"
        # Cette étape utiliserait les manifests Kubernetes et OC CLI

  auto-pr:
    name: Auto Create PR
    runs-on: ubuntu-22.04
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        title: "Auto PR: ${{ github.event.head_commit.message }}"
        body: |
          ## Pull Request Automatique
          
          Ce PR a été créé automatiquement par le workflow CI.
          
          **Changements:**
          - ${{ github.event.head_commit.message }}
          
          **Statut CI:** ✅ Tous les checks doivent passer avant merge
          
          **Merge automatique:** Ajouter le label `auto-merge` pour merge automatique
        branch: "auto-pr-${{ github.sha }}"
        base: main
        labels: "automated-pr"
        delete-branch: true
    
  ci:
    name: CI Status
    runs-on: ubuntu-22.04
    needs: [test, build, notebook-test, deploy-coverage]
    if: always()
    
    steps:
    - name: Aggregate CI status
      id: ci-status
      run: |
        # Vérifier le statut de tous les jobs requis
        if [[ "${{ needs.test.result }}" == "success" && "${{ needs.build.result }}" == "success" && "${{ needs.notebook-test.result }}" == "success" ]]; then
          echo "All required checks passed"
          echo "CI status: success"
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "Some checks failed"
          echo "CI status: failure"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Create status badge
      if: always()
      run: |
        if [[ "${{ steps.ci-status.outputs.status }}" == "success" ]]; then
          echo "Creating success badge"
          echo "![CI Status](https://img.shields.io/badge/CI-passing-brightgreen)" > ci-status.md
        else
          echo "Creating failure badge"
          echo "![CI Status](https://img.shields.io/badge/CI-failing-red)" > ci-status.md
        fi
    
    - name: Upload CI status artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ci-status
        path: ci-status.md